#!/usr/bin/env node

const { execSync } = require('child_process');
const path = require('path');
const fs = require('fs');
const _ = require('lodash');

const URL = 'https://raw.githubusercontent.com/greeny/SatisfactoryTools/u4-dev/data/data.json';
const OUTPUT_JSON = path.join(__dirname, '..', 'src', 'utils', 'data.json');
const OUTPUT_TYPES = path.join(__dirname, '..', 'src', 'utils', 'data.d.ts');
const OUTPUT_IMAGES = path.join(__dirname, '..', 'public', 'images');
const CACHE = '/tmp/satisfactory-baseData.json';

function init() {
    if (fs.existsSync(CACHE)) {
        console.log('❗Using cache:', CACHE);
    } else {
        console.log('❕Creating new cache:', CACHE);
        fs.writeFileSync(CACHE, execSync(`curl -s '${URL}'`).toString().trim());
    }

    const baseData = require(CACHE);
    const data = processData(baseData);
    saveData(data);
}

function processData(data) {
    data = _.cloneDeep(data);
    data.buildingRecipes = {};
    data.recipeGroups = {};
    const keepBuildings = {};
    const keepItems = {};

    for (const bucket in data) {
        _.forEach(data[bucket], (x, key) => {
            data[bucket][key] = {
                id: key,
                ..._.pick(x, ['name', 'slug']),
                // icon: 'https://u4.satisfactorytools.com/assets/images/items/' + x.slug + '_256.png',
                icon: '/images/' + x.slug + '.png',
                ...x,
            };
        });
    }

    _.forEach(data.recipes, (recipe, key) => {
        recipe.id = key;

        // don't care about recipes for items
        if (recipe.producedIn.length !== 1) {
            delete data.recipes[key];
            return;
        }
        else {
            recipe.producedIn = recipe.producedIn[0];
            keepBuildings[recipe.producedIn] = true;
            recipe.products.forEach(p => { keepItems[p.item] = true; });
            recipe.ingredients.forEach(p => { keepItems[p.item] = true; });
        }

        if (recipe.forBuilding) {
            delete data.recipes[key];
            data.buildingRecipes[key] = recipe;
        } else {
            recipe.products.forEach(p => {
                data.recipeGroups[p.item] = data.recipeGroups[p.item] || [];
                data.recipeGroups[p.item].push(recipe.id);
            });
        }
    });

    _.forEach(data.items, x => { if (!keepItems[x.id]) delete data.items[x.id]; });
    _.forEach(data.recipeGroups, x => { if (!keepItems[x.id]) delete data.recipeGroups[x.id]; });
    _.forEach(data.buildings, x => {
        if (!keepBuildings[x.id] && !/Miner/.test(x.id)) delete data.buildings[x.id];
    });

    data.recipeGroups = _.mapValues(data.recipeGroups, (list, key) => {
        let main = list.filter(x => data.recipes[x]).find(x => !data.recipes[x].alternate) || list[0];
        const alternates = list.filter(x => x !== main);

        return {
            id: key,
            main,
            alternates,
            list,
        };
    });

    // ensure these match and excess is filled in out so TS types are easier
    for (const id of _.difference(Object.keys(data.items), _.map(data.recipeGroups, 'id'))) {
        const item = data.items[id];
        const main = item.id;
        data.recipeGroups[id] = {
            id,
            main,
            alternates: [],
            list: [main],
        };
        data.recipes[id] = data.recipes[id] || {
            id,
            slug: id,
            name: id === 'Desc_OreGold_C'
                ? 'Caterium Ore'
                : _.startCase(id.replace(/^Desc_|_C$/g, '')).split(' ').reverse().join(' '),
            className: id,
            alternate: false,
            time: 1, // @TODO: 1 item/second works for Miners Mk1, does not work for fluids or MK++
            manualTimeMultiplier: 1,
            ingredients: [],
            forBuilding: false,
            inMachine: true,
            inHand: false,
            inWorkshop: false,
            products: [{ item: id, amount: 1 }],
            producedIn: id.includes('Ore') ? 'Desc_MinerMk1_C' : 'Desc_AssemblerMk1_C',
        };
    }

    // remove unused so TS types are less GINORMOUS
    delete data.schematics;
    delete data.buildingRecipes;
    delete data.resources;

    data = Object.fromEntries(_.sortBy(Object.entries(data), 0));

    return data;
}

function saveData(data) {
    console.log('→ write json:', OUTPUT_JSON);
    fs.writeFileSync(OUTPUT_JSON, JSON.stringify(data, null, 4));

    const union = obj => _.map(obj, 'id').map(x => `'${x}'`).join(' | ');

    console.log('→ write types:', OUTPUT_TYPES);
    fs.writeFileSync(
        OUTPUT_TYPES,
        [
            '// ❗ Generated from scripts/download-data.js',
            '// ❗ Do not edit this file manually',
            '',

            `export type BuildingNames = ${union(data.buildings)};\n`,
            `export type GeneratorNames = ${union(data.generators)};\n`,
            `export type ItemNames = ${union(data.items)};\n`,
            `export type MinerNames = ${union(data.miners)};\n`,
            `export type RecipeNames = ${union(data.recipes)};\n`,
        ].join('\n'),
    );

    console.log('→ write images:', OUTPUT_IMAGES);
    execSync(`mkdir -p '${OUTPUT_IMAGES}'`);
    for (const bucket in data) {
        console.log('    →', bucket);
        for (const { slug } of Object.values(data[bucket])) {
            if (!slug) continue;
            const imgPath = path.join(OUTPUT_IMAGES, `${slug}.png`);
            const url = 'https://u4.satisfactorytools.com/assets/images/items/' + slug + '_256.png';
            if (fs.existsSync(imgPath)) continue;
            execSync(`curl '${url}' -so '${imgPath}'`);
        }
    }
}

init();
